

# 暑假打工 2 个 月，让我明白了 Keepalived 高可用的三种路由方案

原文首发：[公众号：悟空聊架构]



你好，我是悟空。

## 前言

上篇我们讲了[Keepalived 底层原理上篇](https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451963624&idx=1&sn=298b4917b0782f4c621589ad78f10ac2&chksm=8d1c0777ba6b8e61a8ed45286057c1a2a530f466bd3dfd293a1eb5d1913f819a5713af7c88cb&token=1036865606&lang=zh_CN#rd)，中篇还是得继续呀，但是发现中篇内容还是很多，一篇讲不完，所以先讲 Keepalived 的路由原理。

在写的过程中，发现路由原理其实挺枯燥的，我想把这个主题用通俗易懂、且有趣的方式讲解出来，但是一直找不到合适的切入点，一次偶然的对话让我的灵感迸发。

话说之前大学放暑假的时候，我到一个餐厅打工了两个月，Title 是`初级传菜员`。正是这次打工经验，为我带来了一波潜藏已久的素材，请听听我的故事吧~

## 一、餐厅角色

在餐厅主要有这几种角色：

- 服务员：负责记录客户已点哪些菜、上菜时间、上菜、划菜。**可以将多个服务员都当做客户端**，相对于传菜员来说。

- 传菜员：负责通知厨房走菜、划菜、传菜。**可以将传菜员当做 Keepalived 组件**。
- 厨师：烹饪、装盘。**可以将厨师当做后台真实服务器**。

流程图如下：

![](05.Keepalived底层原理-路由方案.assets/image-20220711092641820.png)

① 客户点菜下单。

② 服务员记录菜名、上菜时间。这里的上菜时间是指客户要求的上菜时间，因为有些客户可能想等朋友一起来了再吃。

③ 服务员将一份订单交给传菜员，另外一份订单留在包间。

④ 传菜员大声通知多位厨师有哪些菜要做，什么时候开始上菜。

⑤ 厨师准备食材和烹饪。如果缺少食材，厨师还会告诉传菜员，由传菜员转告服务员说这道菜不能做。

⑥ 厨师做好后将菜装在盘子里，然后递给传菜员。

⑦ 传菜员将订单上对应的菜划掉，表示已经做了。

⑧ 传菜员将菜端给服务员。

⑨ 服务员将菜从订单上划掉。

⑩ 服务员将菜端上餐桌。

这个流程简单来说就是**客户下单->服务员传单->传菜员通知->厨师烹饪->传菜员传菜->服务员上菜。**

上面的流程不正是服务员请求数据，将请求都发给了传菜员，传菜员将请求转发给了厨师，厨师处理完后返回结果。妙啊！！

## 二、初探 Keepalived 的路由方案

### 2.1 为什么需要路由方案

上篇我们讲到 Keepalived 的负载均衡调度算法，通过这个算法选出某台真实服务来处理本次客户端请求。

> 就好比传菜员要将要做的菜，告诉其中一个厨师（一般是告诉大厨）。
>
> 而如何告诉厨师呢？是用喇叭喊，还是传呼机，还是走到他旁边告诉他？

> 缺少图

对于 Keepalived 来说，选择了一个真实服务器后，**后续还有两个流程需要梳理下**：

- Keepalived 如何将请求转发给这个服务呢？
- 服务处理完这个请求后，如何将处理结果返回给客户端？

上面两个流程就是 Keepalived 的路由方案要做的事。

Keepalived 的有三种路由方案：NAT、TUN、DR。

### 2.2 配置在哪

具体的配置哪种路由方案在 keepalived.conf 配置文件中，其中有一个 lb_kind 配置，可以配置成 NAT、DR、TUN 三种。目前配置的是 DR 模式。

还有一个配置 lb_algo，这个是配置调度算法的，比如这里配置的 wrr 加权轮询调度算法。

![](05.Keepalived底层原理-路由方案.assets/image-20220711095638257.png)

### 2.3 LVS 的结构和工作原理

上篇我们说到 Keepalived 是利用了 LVS 模块的功能来实现负载均衡的。那么 LVS 的结构是怎么样的呢？

分为两个模块：前端的负载均衡器（Load Balance，简称 LB），后端的多台真实服务器（Real Server, 简称 RS）组成





## 三、深入理解 Keepalived 的路由方案

### 3.1 NAT 路由方案

NAT 的全称是 Network Address Translation，网络地址转换。它有两个功能：

- 使企业内部的私有 IP 可以访问外网，

- 使外部用户可以访问位于公司内部的私有 IP 主机。

> 对于 Keepalived 来说，这种模式就好比餐厅的标准下单上菜模式：多个服务员将订单数据转给传菜员，传菜员通知厨师进行烹饪，厨师把菜做好后转给传菜员，传菜员负责把菜传递给服务员。

如下图所示，LVS 负载调度器有两块网卡，配置了不同的 IP 地址，网卡 eth0 设置为私有 VIP 与内部网络通过交换设备相互连接，网卡 eth1 设置为公网 VIP 与外部网络连通。

示例如下：

eth0 网卡 -> 公网 VIP -> 外部网络

eth1 网卡 -> 私有 VIP -> 交换设备 > 内网网络

原理图如下所示：

![](http://cdn.jayh.club/uPic/image-20220703154558103IAYFpB.png)

① 比如现在 eth0 网卡配置了一个公有 VIP 如 10.1.2.88，客户端发送的请求都是到这个 Public VIP（目标地址）。

② 主 LVS Router 负责接收请求，将请求的目的地址（Public VIP）替换成 NAT VIP（192.168.56.88）。

③ 这个 NAT VIP 和后端服务器同属一个局域网，可以相互访问，请求经过负载均衡调度选择一个真实服务器。

④ LVS 修改数据包中的目标地址和目标端口为真实服务器的。

⑤ 真实服务器处理完请求后，将应答数据返回给 LVS Router。

⑥ LVS Router 将应答数据的源 IP 地址 NAT VIP 和端口转换成 Public VIP 和 LVS 的端口，然后转发给外部网络的客户端。

对于客户端而言，它只和 Public VIP 打交道，并不知道 NAT VIP，更不知道真实服务器的 IP 地址，这个过程也称为 IP 伪装。

### 1.2 LVS-TUN 路由方案

NAT 路由方案的存在瓶颈，由于所有的数据请求及响应的数据包都需要经过 LVS 调度器转发，如果后端服务数量很多，客户端访问流量也很大的话，那么调度器会忙于调度转发和地址替换等操作。

为了解决 NAT 的性能问题，TUN 路由方案是个比较好的选择。TUN 方案中，真实服务器处理完结果后，直接返回给客户端。这就要求真实服务器能够与外部网络连接。

TUN 其实是 tunneling（隧道）的缩写，而 TUN 路由方案就是基于 IP 隧道的一种技术。

我们熟知的 VPN 技术就是 IP 隧道技术。 

IP 隧道其实是一种封装技术，将一个 IP 报文封装在另一个 IP 报文中。

- ① 先将原始数据包进行封装。
- ② 然后添加新的源地址+端口、目标地址+端口。

客户端请求的数据本来是 VIP 地址+端口，LVS 负载均衡选择一台真实服务器的地址和端口，经过 IP 隧道技术后，源地址变为  目的地址变为真实服务器的地址+端口。





![](http://cdn.jayh.club/uPic/image-20220704225428917jJB5pp.png)

### 1.3 LVS-DR 模式

那么 LVS 的 TUN 路由模式有没有什么问题呢？

因为 TUN 的方式必须在 LVS 调度器和真实的服务器之间有一个隧道连接，这个创建隧道的过程会对服务器增加负担。

DR 模式和 TUN 模式的相同之处：

- 用户的请求被调度器负载均衡到真实服务器上，然后真实服务器把响应结果返回给客户端。
- 客户端的请求数据包中目标 IP 为 LVS 的 VIP，源 IP 为客户端 IP。

DR 模式和 TUN 模式不同之处：

- DR 模式要求调度器与后端服务器必须在一个局域网内。
- DR 模式不需要创建 IP 隧道。
- VIP 需要在 LVS 调度器与后端所有的服务器间共享。
- 真实服务器处理完结果后，返回数据包时，设置源 IP 为 VIP 地址，目标 IP 为客户端 IP。
- LVS 调度器和真实服务器在同一物理网段上。同一网段机器数量优先，限制了其应用范围。

![image-20220705074216845](http://cdn.jayh.club/uPic/image-20220705074216845htVV0i.png)



![](http://cdn.jayh.club/uPic/image-202207050743468435E6Njr.png)



https://weread.qq.com/web/reader/fae32ef072021a44fae8fe6k9a132c802349a1158154a83

https://weread.qq.com/web/reader/0e732d007260a7490e70173ke2e329c0261e2ef524fbf75

https://weread.qq.com/web/reader/36732010719ecf6b3676799kc8f3245027cc8ffe9a588b8



https://weread.qq.com/web/reader/634329b05930c06341b7d10k98f3284021498f137082c2e



有位读者朋友对上篇提出一个疑问：[Keepalived 高可用上篇](https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451963624&idx=1&sn=298b4917b0782f4c621589ad78f10ac2&chksm=8d1c0777ba6b8e61a8ed45286057c1a2a530f466bd3dfd293a1eb5d1913f819a5713af7c88cb&token=1036865606&lang=zh_CN#rd)

> 主向备发送的到底是 VRRP 还是 ARP 广播报文？

更正和解答上篇的内容：

- 主向备发送的 VRRP 协议的广播报文，里面携带了优先级 priority 字段。从源码这里可以看出：

缺少源码



- 主向局域网内广播 ARP 请求分组，告诉局域网自己的 IP 地址和 MAC 地址。客户端就知道了主的 IP 地址和 MAC 地址。
- 假如发生了主备切换，虽然 IP 没变，还是 VIP，但是 MAC 地址已经变了。客户端发送 IP 数据报时，从自己的  ARP 高速缓存中找到 VIP 对应的 MAC 地址，把 MAC 地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。   







## 





《Linux 运维之道》

《OpenStack 高可用集群》



