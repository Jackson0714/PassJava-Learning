## 一、前言

### Zoom 漏洞

2020 年 3 月 31 日，研究者公开了 Zoom 的重大安全漏洞，认为 Zoom 并不适用于办公会议。最严重的问题，就是和密码算法与密码管理相关的问题。

比如说，Zoom 使用了 ECB 加密模式，而这种加密模式并不是一种安全的加密模式。

随后，有不少知名的公司、教育机构以及政府组织，出于信息安全的考虑，禁止使用 Zoom，转而寻找替代产品。本该大展身手、攻城略地的时候，Zoom 被闷头打了一棒，把大量的机会拱手让给了竞争对手。

### 为什么要学密码学？

不同于其他的软件工程师，密码学是一个需要深度积累的领域，年头越长，见识越多，越了解其中的坑坑洼洼，生产效率和产品质量也越高。可以这么说，有经验的信息安全工程师，是每一个公司的关键人力资源。

### 如何学习密码学？

密码学最好的书籍，当属Bruce Schneier 的**《应用密码学：协议、算法与 C 源程序》**

- 密码学可以解决什么样的问题？

我们需要了解密码学的基本概念和体系，知道密码学能解决什么样的问题，不能解决什么样的问题。

- 面对具体的问题，我们应该使用什么样的密码技术？

如果遇到具体的问题，我们应该选择什么样的算法，当心什么样的问题。这需要我们了解每一个算法的适用场景，以及它的局限性。

- 面对真实的产品，应该怎样组合不同的密码技术？

一般来说，一个产品里需要组合多种密码技术，才能够实现信息安全。单独耐看的技术，搭配起来可能就是一团糟。这需要我们组合、搭配好不同的密码技术，甚至包括非密码的信息安全技术。也就是把密码技术用起来，解决真实的问题。

## 二、学会哈希函数

### 2.1 单向散列函数：如何保证信息完整性？

什么是单向函数？

单向函数（One-way Function）是正向计算容易，逆向运算困难的函数。也就是说，给定你一个输入，你很容易计算出输出；但是给定你一个输出，你却很难计算出输入是什么。

![](http://cdn.jayh.club/top/156fe7a265039ecb392750fc2byyf317.jpg)

#### 什么是散列函数？

散列函数（Hash Function）是一个可以把任意大小的数据，转行成固定长度的数据的函数。

如说，无论输入数据是一个字节，或者一万个字节，输出数据都是 16 个字节。

因为散列函数经常被人们直译为哈希函数，所以我们也可以称散列值为哈希值。通常的，对于给定的输入数据和散列函数，散列值是确定不变的。

![](http://cdn.jayh.club/top/19554606e3465b79f6ea129a3dd2f61d.jpg)

#### 散列值碰撞

既然输入数据的大小没有限制，而输出结果的数据长度固定，存在散列值相同的两个或者多个数据。

解决办法：散列值越长，存在相同散列值的概率就越小，发生碰撞的可能性就越小。

#### 什么是单向散列函数？

单向散列函数既是一个单向函数，也是一个散列函数。

- 单向散列函数正向计算容易，逆向运算困难；
- 单向散列函数运算结果均匀分布，构造碰撞困难；
- 对于相同的单向散列函数， 给定数据的散列值是确定的，长度是固定的。

雪崩效应（Avalanche Effect）是密码学算法一个常见的特点，指的是输入数据的微小变换，就会导致输出数据的巨大变化。严格雪崩效应指的是，如果输入数据的一位反转，输出数据的每一位都有 50% 的概率会发生变化。

一个适用于密码学的单向散列函数，就要具有雪崩效应的特点，也就是说，如果一个单向散列函数具有雪崩效应，那么对于给定的数据，构造出一个新的、具有相同散列值的数据是困难的。

### 2.2、如何设置合适的安全强度？

#### 什么是安全强度？

N 位的安全强度表示破解一个算法需要 2^N(2 的 N 次方) 次的运算。

组合的强度，由最弱的算法和密钥决定。

#### 安全强度会变吗？

一个算法的安全强度不是一成不变的。随着安全分析的进步，几乎所有密码学算法的安全强度都会衰减。

#### 使用多大的安全强度？

业界内最新推荐的三个常用指标分别是：

- 美国的 NIST（国家标准技术研究所)；

- 德国的 BSI（联邦信息安全办公室）；

- 欧洲的 ECRYPT-CSA（欧洲卓越密码网络）。

![img](http://cdn.jayh.club/top/22828b7a07376a9afd082fdddfa1089e.jpg)

128 位的安全强度，目前来说是安全的。不过，一个需要长期运营的系统，如果性能瓶颈不是问题，现在就可以开始考虑使用 256 位强度的密码算法了。

### 2.3 选择哈希算法应该考虑哪些因素？

判断一个现存的算法，还能不能继续使用是我们选择算法的第一步。根据这个标准，我把常见的算法分为了以下三类：

- 退役的算法；
- 遗留的算法；
- 现行的算法。

退役的算法，就是那些已经退出了历史舞台的算法，它们的安全强度很弱，你一定不能再用了。

什么是遗留的算法？你只要记住，它们存在明显的安全问题，已经不足以支撑现在的安全强度需求了，你一定不要用在新系统中了。

只有现行的算法，没有明显的安全问题，是我们现在可以使用的算法。

![](http://cdn.jayh.club/top/af9f9f99535ea29f54b934cf2ce449a9.jpg)

![](http://cdn.jayh.club/top/e454af18046b37e5d51e575601e119bb.jpg)

![](http://cdn.jayh.club/top/79236952581b4a612749cbec11cc2577.jpg)

#### 为什么有处理能力限制？ 

一个典型的单向散列函数，由四个部分组成：数据分组、链接模式、单向压缩函数和终结函数。

![](http://cdn.jayh.club/top/766c6b81c43b684a0f083c540ea94163.jpeg)

如果输入数据长度超过了数据补齐方案的限制，数据就没有办法分组了。这就是单向散列函数数据处理能力限制的来源。

SHA-3 的设计，放弃了在数据补齐方案里使用固定位数表示输入数据长度的做法，它也就不再有数据处理能力的限制。

#### 算法的性能是怎么决定的？

在一个算法的实现细节中，通常影响计算性能的因素有：

- 算法实现的内存使用影响；

- 算法实现有没有使用优化的步骤，比如并行计算或者预运算？

- 算法实现有没有使用硬件加速，比如使用 CPU 关于算法的扩展指令？

尽量选用现行的、流行的算法。对于单向散列函数，它们是SHA-256，SHA-384和 SHA-512。

### 2.4 如何有效避免长度延展攻击？

单向散列函数在密码学中扮演着重要角色，但其存在长度延展攻击的风险。这种攻击利用已知数据的散列值，计算原数据外加一段延展数据后的散列值，从而构造出一个新的合法的URL，获得不同的授权。为了避免这种攻击，建议不要单纯使用单向散列函数处理既包含机密信息、又包含公开信息的数据，而是应该使用设计好的、经过验证的算法，比如消息验证码和基于单向散列函数的消息验证码。

#### 什么是长度延展攻击？

如果机密信息放在了前面，就存在“长度延展攻击”的风险。

我们之前着重说了数据分组，我们现在来看看其他的部分：

![](http://cdn.jayh.club/top/766c6b81c43b684a0f083c540ea94163.jpeg)

- 单向散列函数处理过程压缩函数是单向函数，负责着算法的单向性要求；

- 终结函数不是单向函数，负责着整理压缩函数的输出，形成散列值的任务；

- 链接模式，负责把下一个数据分组和上一个压缩函数的输出结果结合起来，确保算法的雪崩效应能够延续。

缩函数接收一个数据分组和上一个压缩函数的运算结果。如果知道了上一个压缩函数的运算结果，我们就能够计算下一个分组数据的压缩函数运算结果。这里，就是出现安全漏洞的地方。

![](http://cdn.jayh.club/top/e6339667aff222cbdefa25dc79549638.jpeg)

我们把原来的散列值作为压缩函数的一个输入，我们再按照数据补齐规范，去补齐原来数据到数据分组的整数倍，然后加入新的数据，我们就可以计算原数据和扩展数据的散列值了。

![](http://cdn.jayh.club/top/31e2ea275d7e21d49f34294319e31ea5.jpeg)

新的散列值的计算，不需要知道预先设想的机密数据。但是整个散列值的计算，又的确使用了机密数据。只不过，这个计算过程需要两个部分，第一部分由机密数据的持有者计算，第二部分是攻击者使用第一部分的结果，伪造了一个使用了机密数据的散列值。

但是，如果我们把数据编排顺序换一下，把公开信息 M 放在前面，机密信息 S 放在后面，长度延展攻击就不起作用了。这就是数据编排顺序对数据安全性的影响。

#### 怎么有效避免长度延展攻击？

不要单纯使用单向散列函数来处理既包含机密信息、又包含公开信息的数据。

如果我们需要使用机密数据产生数据的签名，我们应该使用设计好的、经过验证的算法，比如我们后面会讨论的消息验证码（Message Authentication Code）和基于单向散列函数的消息验证码（Hash-based Message Authentication Code）。

算法要皮实、耐用，不能有意无意地用错了就有安全漏洞。

- 典型的使用单向散列函数的场景：

- 校验数据完整性；

- 数字签名，和非对称密钥及其算法结合使用；

- 消息验证码，和对称密钥及其算法结合使用；

- 生成伪随机数；生成对称密钥。

## 三、学会使用对称密钥算法

### 3.1 对称密钥：如何保护私密数据？

现代的密码学算法的安全性，都是基于密钥的保密，而不是算法保密要求。管理好密钥，做好密钥的保密，才是密码学系统最关键的任务。

对称密钥，顾名思义，就是每一个参与者都持有相同的密钥，使用相同的密钥。

![](http://cdn.jayh.club/top/e6eb19e271ecce7bedf629792d7ddfc3.jpeg)

非对称密钥，就是指每一个参与者都持有不同的密钥，使用不同的密钥。

![](http://cdn.jayh.club/top/bab7b6ae0c35d2a5dbb56c32d3f139eb.jpeg)

### 3.2 怎么选择对称密钥算法？

数据加密会影响性能，但是这个影响并不显著。

优先选择的三个算法：ChaCha20，AES-256，AES-128

#### 序列算法和分组算法

- 进行数据分组，然后按数据组运算，这就是分组算法；

- 不进行数据分组，按照原始数据的大小进行运算，这就是序列算法。如 ChaCha20 算法

序列算法的基本思路，就是从对称密钥里推导出一段和明文数据相同长度的密钥序列，然后密钥序列和明文进行异或运算得到密文，和密文进行异或运算得到明文。

![](http://cdn.jayh.club/top/4cbebbcebbb39yy413861a9637ce81d2.jpg)

在类似的条件下，相同安全强度的对称密钥，ChaCha20 算法要比 AES 算法快四到六倍。

### 3.3 该怎么选择初始化向量？

#### 分组算法怎么计算？

分组算法要对输入数据进行分组，然后按数据分组来进行运算。一个典型的分组算法，一般要由三个部分组成，数据分组、分组运算和链接模式。

![](http://cdn.jayh.club/top/55e1d4yy57f6c0afbe91a45ed792192f.jpeg)

如果不能整分，就要把最后一个分组补齐成 128 位。这些分组数据的运算结果，组合起来就是密文数据。解密时，执行相反的操作，把补齐数据去掉，再把数据分组组合成完整的明文数据。

![](http://cdn.jayh.club/top/3eee1786e229e6fb3867931cb43010e4.jpeg)

分组运算，意思就是把每一个明文数据分组通过加密函数，转换成密文数据分组。而链接模式，指的是如何把上一个分组运算和下一个分组运算联系起来。

有一点需要说，第一个分组运算并没有上一个分组运算可以使用，这时候，我们就需要引入一个初始化的数据，来承担“上一个分组运算”向下链接的功能。这个初始化的数据，我们一般称为**初始化向量**。

在分组运算里，链接模式也承担类似的功能：

- 不同的明文数据，它的密文数据应该是完全不同的，即使明文数据里包含相同的数据分组；
- 相同的明文数据，每一次的加密运算，它的密文数据也应该是完全不同的。

#### 什么影响算法的安全性？

- 加密函数和解密函数；
- 密钥；
- 初始化向量；
- 链接模式；
- 数据补齐方案。

#### 初始化向量怎么选？

我们要想了解初始化向量对算法安全性的影响，就要先看看第一个数据块是怎么计算的，第一个数据块和初始化向量关系紧密。第一个数据块的计算，它的输入信息包括：

- 密钥；
- 初始化向量；
- 第一个明文数据分组。

![](http://cdn.jayh.club/top/00406ae41ab45bd6bf395d32e7133540.jpeg)

如果我们能够确定这些输入信息，那么输出的第一个密文数据分组也就确定了。

在一个对称密钥的生命周期里，初始化向量不能重复，这是使用对称密钥算法的第一个要求。

#### 一个密钥能用多少次？

比如，一个 128 位的初始化向量，最多有 2^ 128 个不重复的数值。进一步的说，对于这个算法，一个密钥最多只能使用 2^ 128 次。的确看起来，2^128 是一个巨大的数字，一般的应用程序也没有什么机会使用这么多次加密运算。

当然，还有其他因素限制密钥的使用次数。很多限制因素的叠加，就会使得密钥使用的限制数远远低于初始化向量的许可数目。所以，我们心里一定要知道，密钥是有使用次数限制的，并且要有检查密钥使用次数限制的习惯。

### 3.4 为什么 ECB 模式不安全？

ECB模式是一种不安全的加密模式，因为它不使用链接模式，也不需要初始化向量，导致相同的明文分组会被加密成相同的密文分组。这使得攻击者可以通过寻找重复的密文，推断未知数据，甚至进行“分组重放”攻击。虽然ECB模式具有独立运算、并行运算的特性，但其安全缺陷使其不适合在实际加密应用中使用。因此，对称密钥算法的链接模式和数据补齐方案对算法安全性有着重要影响，需要特别关注和理解每种模式的原理，避免掉入安全陷阱。

#### 链接模式怎么连？

![](http://cdn.jayh.club/top/25b0e86ec7352c98f332f2413c6e0220.jpg)

从道理上来说，上一个分组运算的所有要素，都有可能参与到下一个分组运算里；下一个分组运算的每一个要素，都有可能接收上一个运算的一个要素或者几个要素的组合。而在这之间，就会形成不同的分配组合，也就形成了不同的链接模式。

#### ECB 模式什么样？

我们先来简单地了解一下 ECB 模式是怎么工作的。

![](http://cdn.jayh.club/top/dfc31523655e5a4c72ccdc041a3d4327.jpg)

ECB 模式有所不同，它不使用链接模式，因此它也用不着初始化向量。

不使用链接模式，就意味着上一个分组运算不影响下一个分组运算，每一个数据分组的运算都是独立的。不需要初始化向量、每一个数据分组运算都是独立的，这特性令人振奋。

##### ECB 模式优点

- 可以并行运算，意味着运算效率的大幅度提高；

- 没有次序要求，意味着每一段加密数据都可以独立地存取、解密、修改、删除。而且，添加、插入新的数据段，也不会对其他数据段产生影响。

##### ECB 模式缺点

- 如果一个加密运算缺失初始化向量，相同的明文分组就会被加密成相同的密文分组。只要通过定位数据块，锚定对应的密文，就可以利用已知数据块和密文寻找、推断未知数据了。

#### 什么时候使用 ECB 模式？

分组算法的最基本运算，就是转换一个固定长度的数据块。这个单个数据块的转换，就是 ECB 模式下的运算。有密码学专业知识的算法工程师，可以通过合理地使用 ECB 模式，来构造更复杂、更安全的算法。不过，我们不应该在一般的应用程序使用 ECB 模式。

### 3.5 怎么防止数据重放攻击？

CBC 模式，可能是 2018 年之前最常用、最常见的加密模式。和 ECB 模式不同，由于初始化向量和链接模式的使用，CBC 模式解决了数据重放攻击的问题。可是，从 2018 年开始，由于它的安全问题，CBC 模式开始退出历史舞台，尽管这一进程可能需要十数年，甚至数十年。

#### 为什么还要学习 CBC 模式？

- CBC 的退出进程可能需要十数年才能完成。
- 学习针对 CBC 的攻击方案， 是我们深入理解加密算法安全问题的最好的切入点。
- 理解初始化向量和链接模式对加密算法的影响。

#### CBC 模式什么样？

明文分组在加密之前，要与前一组的密文分组进行异或运算，异或运算的结果会参与加密函数的运算。

每一个密文分组，都依赖于前面所有的明文分组，包括初始化向量。

![](http://cdn.jayh.club/top/3b93c00b26a591bde63b50a1f2f1b52d.jpeg)



CBC 模式是需要初始化向量的。我们需要一个外部引入的初始化向量来替代“上一个密文分组”参与运算。

解密过程如下所示：

![](http://cdn.jayh.club/top/6e44f9b084b3233d0e5fb6bed0d5687e.jpeg)

注意一点，初始化向量只影响第一个明文分组，并不影响后续的解密过程和明文分组。

类似地，一个密文分组，只影响它的下一个明文分组，并不影响更后面的解密过程和明文分组。

而在加密过程中，每一个密文分组，都依赖于前面所有的明文分组，包括初始化向量。

三个关键点：

- 加密和解密要使用初始化向量；

- 加密和解密的初始化向量是等同的；

- 上一次的密文分组参与下一次的加密和解密运算。

如果初始化向量重复使用，相同的明文就会有相同的密文，就会和 ECB 模式一样脆弱。

#### 异或运算

相同的数据归零，不同的数据归一。

异或运算是按位运算，运算时间和复杂度只和数据的位数相关，和数据的实际数值无关。

### 3.6 怎么利用解密端攻击？

利用数据补齐方案，来展开补齐预言攻击，我们知道了数据补齐方案可能存在的缺陷。

阻断补齐预言攻击的办法：每一次加密 / 解密计算，都使用初始化向量，而不是仅仅就使用一次初始化向量。

### 3.7 怎么利用加密端攻击？

攻击者可以构造明文分组，调用加密运算，观测加密运算后的密文分组，从而破解目标明文分组的具体数据。虽然完整破解一个16字节的明文分组不可行，但攻击者可以逐个破解字节，尤其对于敏感数据如手机验证码，攻击者只需进行有限次计算即可破解。这种攻击技术被称为BEAST，曾在2011年引起广泛关注。由于其严重性，CBC模式已经开始逐渐退出加密算法的主流应用，新的协议或应用不应再使用CBC模式，现有的协议或应用也需要采取措施防范BEAST攻击。

为了防范BEAST攻击，可以在初始化向量上做文章。一种改进的办法是继续使用上一次加密运算的最后一个密文分组，同时把每一次运算的初始化向量当做第一个明文分组来处理。这样的好处是解密端不需要知道加密端选择的初始化向量，就可以执行解密运算。然而，解密端需要丢掉初始化向量这一段数据，不能把它当做应用数据来处理。另一种替代方案是每一次加密运算都使用不同的初始化向量，但这会带来初始化向量同步的问题。

### 3.8 如何防止数据被调包？

#### 怎样有效地验证一段信息？

需要满足以下条件：

- 我们要有额外的信息。
- 验证信息和待验证的消息之间要有关联。
- 验证信息的计算要快，数据要小。

消息验证码（Message Authentication Code, MAC）就是最常用的满足上述三个条件的一个方案。

![](http://cdn.jayh.club/top/d5eee6ab3fe89befdd25f8cfbe521ec9.jpeg)

信息发送方把待验证信息和消息验证码都发送给信息接收方。信息接收方使用相同的消息验证函数和对称密钥，以及接收到的待验证信息，生成消息验证码。消息验证函数需要使用对称密钥。

#### 该怎么选择消息验证函数？

最常见的方案就是基于单向散列函数的消息验证码（HMAC）。

- 正向计算容易，逆向运算困难；

- 运算结果均匀分布，构造碰撞困难；
- 给定数据的散列值是确定的，长度固定。

#### 有哪些常见的 HMAC 算法？

![](http://cdn.jayh.club/top/5409851byy6b8c39102fee2b98aaa720.jpeg)

![](http://cdn.jayh.club/top/6fe58983135d71e44afe36cf2b8797c8.jpeg)

HmacSHA256 和 HmacSHA384 是目前最流行的两个 HMAC 算法。

### 3.9 加密数据能够自我验证吗？

加密并验证以及验证后加密这两种方案存在安全缺陷；加密后验证是一个更安全的方案。

带关联的认证加密算法能够进行自我验证。

#### 加密后验证

加密明文数据，计算明文数据的消息验证码，输出密文数据和验证码。

安全外壳协议（SSH）就是采用加密并验证的方案。

![img](http://cdn.jayh.club/top/481b4ff097445e77b857ed393365a3a9.jpeg)

这个方案的消息验证码，保护的是明文信息的完整性，而不是密文信息的完整性。如果明文信息相同，它的消息验证码也是相同的。从攻击者的角度看，如果发现两个相同的消息验证码，就可以猜测明文信息大概率是相同的。

#### 加密后验证

加密明文数据，计算加密数据的消息验证码，输出密文数据和验证码。

IPSec 协议采用的就是加密后验证的方案。

![](http://cdn.jayh.club/top/481b4ff097445e77b857ed393365a3a9.jpeg)

### 验证后加密

计算明文数据的消息验证码，加密明文数据和验证码，输出密文数据。
SSL 协议采用的就是验证后加密的方案

![](http://cdn.jayh.club/top/f5c74b157fe850fb7d2c0d8yye1219a8.jpeg)

这个方案的消息验证码，保护的是明文信息的完整性，而不是密文信息的完整性。如果我们把明文信息和消息验证码看作是一个数据，我们前面提到的 CBC 攻击方案是不是似乎又回来了？

#### 该选用哪一个方案？

加密后验证这个方案目前来说，是最安全的方案。

#### 带关联数据的加密

带关联的认证加密（Authenticated Encryption with Associated Data（AEAD））

带关联的认证加密算法能够进行自我验证

加密过程：

![](http://cdn.jayh.club/top/e5b3fb7f799d6ae2d8fc4276572a0546.jpeg)

解密过程：

![](http://cdn.jayh.club/top/a9920f861a3fd6103f3d325ddac8b573.jpeg)

### 3.10 AEAD有哪些安全陷阱？

常见的AEAD算法，包括GCM、CCM和Poly1305，当前推荐使用的算法是AES/GCM、ChaCha20/Poly1305和AES/CCM。

AEAD 算法初始化向量不能重复的要求。

AEAD 算法常用的初始化向量选择方案：

- 使用随机数作为初始化向量。
- 使用序列数作为初始化向量。

### 3.10 为什么说随机数都是骗人的？

计算机的存在基于确定性，因此在计算机世界中，真正的随机数是不存在的，所谓的随机数实际上是伪随机数。

随机数的质量取决于私密数据的质量和计算输出的算法。

随机数产生可能会阻塞。

### 3.11 加密密钥是怎么来的？

对称密钥的两个主要来源：基于口令的密钥推导和使用随机数生成对称密钥。

基于口令的密钥推导通过口令生成对称密钥，但由于口令的安全性有限，需要经常变换口令以提高安全性。另一方面，使用随机数生成对称密钥能够满足对称密钥的长度、强度和保密要求，但随机数无法被人脑记忆，需要计算机来管理和保密对称密钥。

### 3.12 如何管理对称密钥？

#### 即用即弃的对称密钥

用在加密数据不需要保存的场景。比如说， 像 HTTPS 这样的端到端传输协议，它的网络传输数据是加密的，而加密的网络传输数据是不需要保存到硬盘里的。

#### 需要留存的对称密钥

大部分出现在用户无法参与的计算环境里。

留存的对称密钥需要得到额外的照顾，避免对称密钥的泄漏。比如说，保存对称密钥的文件，它的权限需要设置成只有它的拥有者才能阅读、修改。在高度保密的环境下，甚至，我们需要把对称密钥保存到专用的芯片里。

对称密钥的规模化是使用对称密钥的一个大麻烦。

### 3.13 量子时代，你准备好了吗？

随着量子计算机性能的飞速提升，传统的对称密钥加密算法可能无法抵御量子计算时代的算力。然而，256位的对称密钥算法和单向散列函数，如AES算法，在量子计算时代仍然是安全的。相比之下，所有现行的非对称密码算法都无法抵御量子计算时代的算力，因此业界正在紧锣密鼓地设计和遴选适用于量子计算时代的非对称密码算法。

#### 前向保密性

具备前向保密性的对称密钥需要满足两个特点：密钥的产生需要有即用即弃的随机数的参与，且密钥本身是即用即弃的，而不能是静态的























































