# Redis 的缓存策略

## 一、Redis 缓存有哪些淘汰策略？

Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。我们可以按照是否会进行数据淘汰把它们分成两类：

- 不进行数据淘汰的策略，只有 noeviction 这一种。

- 会进行淘汰的 7 种其他策略。

会进行淘汰的 7 种策略，我们可以再进一步根据淘汰候选数据集的范围把它们分成两类：
- 在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。
- 在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种。

![img](http://cdn.jayh.club/uPic/04bdd13b760016ec3b30f4b02e133df6.jpg)

**noeviction**，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据。一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。

**volatile-ttl** 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。

**volatile-random** 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。

**volatile-lru** 会使用 LRU 算法筛选设置了过期时间的键值对。

**volatile-lfu** 会使用 LFU 算法选择设置了过期时间的键值对。

**allkeys-random** 策略，从所有键值对中随机选择并删除数据。

**allkeys-lru** 策略，使用 LRU 算法在所有数据中进行筛选。有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。

**allkeys-lfu** 策略，使用 LFU 算法在所有数据中进行筛选。



## 二、LRU 淘汰算法

LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。

![img](http://cdn.jayh.club/uPic/0201f85c84203300ae4085c60e955yy5.jpg)



## 三、长尾效应和重尾效应

![img](http://cdn.jayh.club/uPic/986ed247a4353524f387f0bbf76586e4.jpg)

### 3.1 长尾效应

有 20% 的数据贡献了 80% 的访问了，而剩余的数据虽然体量很大，但只贡献了 20% 的访问量。这 80% 的数据在访问量上就形成了一条长长的尾巴，我们也称为“长尾效应”。

### 3.2 重尾效应

20% 的数据可能贡献不了 80% 的访问，而剩余的 80% 数据反而贡献了更多的访问量，我们称之为重尾效应。

建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。

## 四、小测验

**问题**：Redis 缓存在处理脏数据时，不仅会修改数据，还会把它写回数据库。我们在前面学过 Redis 的只读缓存模式和两种读写缓存模式（带同步直写的读写模式，带异步写回的读写模式）），请你思考下，Redis 缓存对应哪一种或哪几种模式？

**答案**：如果我们在使用 Redis 缓存时，需要把脏数据写回数据库，这就意味着，Redis 中缓存的数据可以直接被修改，这就对应了读写缓存模式。更进一步分析的话，脏数据是在被替换出缓存时写回后端数据库的，这就对应了带有异步写回策略的读写缓存模式。

