# 面试题汇总 Redis 篇 第一季

面试题第一时间会发到我的知识星球和群聊里面。

## 每天一道面试题-悟空聊架构 1/365
悟空拧螺丝 2021-07-13

>Redis 为什么快呢?

redis 的速度非常的快，单机的 redis 就可以支撑每秒 10 几万的并发，相对于 mysql 来说，性能是 mysql 的几十倍。速度快的原因主要有几点:
1. 完全基于内存操作
2. C 语言实现，优化过的数据结构，基于几种基础的数据结构，redis 做了大量的优化，性能极高
3. 使用单线程，无上下文的切换成本
4. 基于非阻塞的 IO 多路复用机制

## 每天一道面试题-悟空聊架构 2/365
悟空拧螺丝 2021-07-14

>Redis 的 RDB 是什么？

Redis 持久化方案分为 RDB 和 AOF 两种。

RDB 持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到
RDB 文件中，RDB 文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于 RDB
文件是保存在硬盘上的，所以即使 redis 崩溃或者退出，只要 RDB 文件存在，就可以用它来恢复还原数
据库的状态。

可以通过 SAVE 或者 BGSAVE 来生成 RDB 文件。

SAVE 命令会阻塞 redis 进程，直到 RDB 文件生成完毕，在进程阻塞期间，redis 不能处理任何命令请
求，这显然是不合适的。

BGSAVE 则是会 fork 出一个子进程，然后由子进程去负责生成 RDB 文件，父进程还可以继续处理命令请
求，不会阻塞进程。

## 每天一道面试题-悟空聊架构 3/365
悟空拧螺丝 2021-07-15
>Redis 的 AOF 持久化是什么？

AOF 和 RDB 不同，AOF 是通过保存 redis 服务器所执行的写命令来记录数据库状态的。 先执行命令后记录命令。AOF 通过追加、写入、同步三个步骤来实现持久化机制。
1. 当 AOF 持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加 append 到 aof_buf 缓 冲区的末尾
2. 在服务器每结束一个事件循环之前，将会调用 flushAppendOnlyFile 函数决定是否要将 aof_buf 的 内容保存到 AOF 文件中，可以通过配置 appendfsync 来决定。
AOF 配置项 appendfsync 的三个可选值。

Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；

Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；

No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

![AOF 持久化思维导图](http://cdn.jayh.club/blog/20210719/1HIRa5HoBfqx.png?imageslim)

## 每天一道面试题-悟空聊架构 4/365
悟空拧螺丝 2021-07-16
>Redis的底层数据有哪些？

底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。

## 每天一道面试题-悟空聊架构 5/365
悟空拧螺丝 2021-07-17
>Redis 如何实现事务？

事务的执行过程包含三个步骤，Redis 提供了 MULTI、EXEC 两个命令来完成这三个步骤。

第一步，客户端要使用一个命令显式地表示一个事务的开启。在 Redis 中，这个命令就是 MULTI。

第二步，客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端。这些操作就是 Redis 本身提供的数据读写命令，例如 GET、SET 等。不过，这些命令虽然被客户端发送到了服务器端，但 Redis 实例只是把这些命令暂存到一个命令队列中，并不会立即执行。

第三步，客户端向服务器端发送提交事务的命令，让数据库实际执行第二步中发送的具体操作。Redis 提供的 EXEC 命令就是执行事务提交的。当服务器端收到 EXEC 命令后，才会实际执行命令队列中的所有命令。


![Redis 实现事务思维导图](http://cdn.jayh.club/blog/20210719/6aCSMVBJFGPm.png?imageslim)

## 每天一道面试题-悟空聊架构 6/365
悟空拧螺丝 2021-07-18
>Redis的 watch 机制的作用？

一个事务的 EXEC 命令还没有执行时，事务的命令操作是暂存在命令队列中的。此时，如果有其它的并发操作，我们就需要看事务是否使用了 WATCH 机制。

WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。

WATCH 机制的具体实现是由 WATCH 命令实现的，如下图所示：
![Redis 的 watch 机制流程图](http://cdn.jayh.club/blog/20210719/0Hj7AvHOSTtk.png?imageslim)

## 每天一道面试题-悟空聊架构 7/365
悟空拧螺丝 2021-07-19

> Redis的淘汰策略有哪几种？

volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。

volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。

volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。最近最少使用的会被删掉。

volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。首先会筛选并淘汰访问次数少的数据，然后针对访问次数相同的数据，再筛选并淘汰访问时间最久远的数据。

allkeys-random 策略，从所有键值对中随机选择并删除数据。

allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。

allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。

默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。写满后再写会返回错误。

![缓存淘汰策略思维导图](http://cdn.jayh.club/blog/20210719/mN9k2x414bGA.png?imageslim)

## 每天一道面试题-悟空聊架构 8/365

悟空拧螺丝 2021-07-20

> 说说 Redis 的缓存雪崩？

![](http://cdn.jayh.club/blog/20210720/j9zyGeeDcGgP.png?imageslim)

缓存雪崩是指我们缓存多条数据时，采用了相同的过期时间，比如 00:00:00 过期，如果这个时刻缓存同时失效，而有大量请求进来了，因未缓存数据，所以都去查询数据库了，数据库压力增大，最终就会导致雪崩。 

### 带来的风险

尝试找到大量 key 同时过期的时间，在某时刻进行大量攻击，数据库压力增大，最终导致系统崩溃。 

### 解决方案

1.在原有的实效时间基础上增加一个随机值，比如 1-5 分钟随机，降低缓存的过期时间的重复率，避免发生缓存集体实效。 

2.Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。

3.限流，如果 redis 宕机，可以限流，避免同时刻大量请求打崩 DB。

4.Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

5.热点key识别+本地缓存。

6.singleflight降低缓存并发重复读。

