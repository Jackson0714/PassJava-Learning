# 面试题汇总 Redis 篇 第一季

大家好，我是悟空。

> 先说下哈，这次给大家带来的大厂面试题，都来源于我的知识星球。

请扫码进入知识星球查看！

![](https://img-blog.csdnimg.cn/2021071922263371.png)

> 面试题第一时间会发到我的知识星球和群聊里面。

文中图片来源：有部分自己画的，有部分来源极客时间，感谢极客时间提供的学习平台。

[TOC]

## 1、Redis 为什么快呢?

悟空拧螺丝 2021-07-13

>Redis 为什么快呢?

redis 的速度非常的快，单机的 redis 就可以支撑每秒 10 几万的并发，相对于 mysql 来说，性能是 mysql 的几十倍。速度快的原因主要有几点:
1. 完全基于内存操作
2. C 语言实现，优化过的数据结构，基于几种基础的数据结构，redis 做了大量的优化，性能极高
3. 使用单线程，无上下文的切换成本
4. 基于非阻塞的 IO 多路复用机制

## 2、Redis 的 RDB 是什么？

悟空拧螺丝 2021-07-14

>Redis 的 RDB 是什么？

Redis 持久化方案分为 RDB 和 AOF 两种。

RDB 持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到
RDB 文件中，RDB 文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于 RDB
文件是保存在硬盘上的，所以即使 redis 崩溃或者退出，只要 RDB 文件存在，就可以用它来恢复还原数
据库的状态。

可以通过 SAVE 或者 BGSAVE 来生成 RDB 文件。

SAVE 命令会阻塞 redis 进程，直到 RDB 文件生成完毕，在进程阻塞期间，redis 不能处理任何命令请
求，这显然是不合适的。

BGSAVE 则是会 fork 出一个子进程，然后由子进程去负责生成 RDB 文件，父进程还可以继续处理命令请
求，不会阻塞进程。

## 3、Redis 的 AOF 持久化是什么？

悟空拧螺丝 2021-07-15
>Redis 的 AOF 持久化是什么？

AOF 和 RDB 不同，AOF 是通过保存 redis 服务器所执行的写命令来记录数据库状态的。 先执行命令后记录命令。AOF 通过追加、写入、同步三个步骤来实现持久化机制。
1. 当 AOF 持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加 append 到 aof_buf 缓 冲区的末尾
2. 在服务器每结束一个事件循环之前，将会调用 flushAppendOnlyFile 函数决定是否要将 aof_buf 的 内容保存到 AOF 文件中，可以通过配置 appendfsync 来决定。
AOF 配置项 appendfsync 的三个可选值。

Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；数据基本不丢失，性能较差。

Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；宕机时丢失 1s 内的数据，性能较好。

No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘；宕机时丢失数据较多。

![AOF 持久化思维导图](http://cdn.jayh.club/blog/20210719/1HIRa5HoBfqx.png?imageslim)

## 4、Redis的底层数据有哪些？

悟空拧螺丝 2021-07-16
>Redis的底层数据有哪些？

底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。

![在这里插入图片描述](http://cdn.jayh.club/uPic/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oKf56m66IGK5p625p6E,size_20,color_FFFFFF,t_70,g_se,x_16WmymNf.png)

## 5、Redis 如何实现事务？

悟空拧螺丝 2021-07-17
>Redis 如何实现事务？

事务的执行过程包含三个步骤，Redis 提供了 MULTI、EXEC 两个命令来完成这三个步骤。

第一步，客户端要使用一个命令显式地表示一个事务的开启。在 Redis 中，这个命令就是 MULTI。

第二步，客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端。这些操作就是 Redis 本身提供的数据读写命令，例如 GET、SET 等。不过，这些命令虽然被客户端发送到了服务器端，但 Redis 实例只是把这些命令暂存到一个命令队列中，并不会立即执行。

第三步，客户端向服务器端发送提交事务的命令，让数据库实际执行第二步中发送的具体操作。Redis 提供的 EXEC 命令就是执行事务提交的。当服务器端收到 EXEC 命令后，才会实际执行命令队列中的所有命令。


![Redis 实现事务思维导图](http://cdn.jayh.club/blog/20210719/6aCSMVBJFGPm.png?imageslim)

## 6、Redis的 watch 机制的作用？

悟空拧螺丝 2021-07-18
>Redis的 watch 机制的作用？

一个事务的 EXEC 命令还没有执行时，事务的命令操作是暂存在命令队列中的。此时，如果有其它的并发操作，我们就需要看事务是否使用了 WATCH 机制。

WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。

WATCH 机制的具体实现是由 WATCH 命令实现的，如下图所示：
![Redis 的 watch 机制流程图](http://cdn.jayh.club/blog/20210719/0Hj7AvHOSTtk.png?imageslim)

## 7、Redis的淘汰策略有哪几种？

悟空拧螺丝 2021-07-19

> Redis的淘汰策略有哪几种？

源码在这里：redis.conf 文件

![](http://cdn.jayh.club/blog/20210803/SXDROYOmGSr7.png?imageslim)

**volatile-ttl** 策略，在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。

**volatile-random**策略，在设置了过期时间的键值对中，进行随机删除。

**volatile-lru** 策略，会使用 LRU 算法筛选设置了过期时间的键值对。最近最少使用的会被删掉。

**volatile-lfu** 会使用 LFU 算法选择设置了过期时间的键值对。首先会筛选并淘汰访问次数少的数据，然后针对访问次数相同的数据，再筛选并淘汰访问时间最久远的数据。

**allkeys-random** 策略，从所有键值对中随机选择并删除数据。

**allkeys-lru** 策略，使用 LRU 算法在所有数据中进行筛选。

**allkeys-lfu** 策略，使用 LFU 算法在所有数据中进行筛选。

默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。写满后再写会返回错误。

![缓存淘汰策略思维导图](http://cdn.jayh.club/blog/20210803/Agb1i5QTBEbi.png?imageslim)

## 8、说说 Redis 的缓存雪崩？

悟空拧螺丝 2021-07-20

> 说说 Redis 的缓存雪崩？

![](http://cdn.jayh.club/blog/20210720/j9zyGeeDcGgP.png?imageslim)

缓存雪崩是指我们缓存多条数据时，采用了相同的过期时间，比如 00:00:00 过期，如果这个时刻缓存同时失效，而有大量请求进来了，因未缓存数据，所以都去查询数据库了，数据库压力增大，最终就会导致雪崩。 

### 带来的风险

尝试找到大量 key 同时过期的时间，在某时刻进行大量攻击，数据库压力增大，最终导致系统崩溃。 

### 解决方案

1.在原有的实效时间基础上增加一个随机值，比如 1-5 分钟随机，降低缓存的过期时间的重复率，避免发生缓存集体实效。 

2.Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。

3.限流，如果 redis 宕机，可以限流，避免同时刻大量请求打崩 DB。

4.Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

5.热点key识别+本地缓存。

6.singleflight降低缓存并发重复读。

## 9、说说 Redis 的缓存穿透？

悟空拧螺丝 2021-07-21 

> 说说缓存穿透？ 

### 缓存穿透的概念

缓存穿透指一个一定不存在的数据，由于缓存未命中这条数据，就会去查询数据库，数据库也没有这条数据，所以返回结果是 `null`。如果每次查询都走数据库，则缓存就失去了意义，就像穿透了缓存一样。 

![](http://cdn.jayh.club/uPic/e0583ebe4afd27e8278577f84fa8c735.png)

### 带来的风险

利用不存在的数据进行攻击，数据库压力增大，最终导致系统崩溃。 

### 为什么会产生缓存穿透

- 业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；
- 恶意攻击：专门访问数据库中没有的数据。 

### 解决方案

- 对结果 `null` 进行缓存，并加入短暂的过期时间。 
- 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。 -
- 前端进行请求检测。把恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库。

## 10、说说Redis 的缓存击穿？

悟空拧螺丝 2021-07-22

> 说说缓存击穿？

#### 缓存击穿的概念

某个 key 设置了过期时间，但在正好失效的时候，有大量请求进来了，导致请求都到数据库查询了。就像把一面墙击穿了一个洞。

![](https://img-blog.csdnimg.cn/img_convert/1709976ea1985652f7dfc90edd5d8dec.png)

#### 解决方案

不同场景下的解决方式可如下：

- 若缓存的数据是**基本不会发生更新**的，尝试将该热点数据设置为永不过期。

- 若缓存的数据**更新不频繁**，且**缓存刷新**的整个流程**耗时较少**的情况下，则可以采用基于Redis、Zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。

- 若缓存的数据**更新频繁**或者在**缓存刷新**的流程**耗时较长**的情况下，可以利用**定时线程**在缓存**过期前**主动地重新构建缓存或者**延后**缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

## 11、单机系统下，Redis 如何实现并发控制？

悟空拧螺丝 2021-07-23

> 单机系统下，Redis 如何实现并发控制？

为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：

- **单命令操作**：把多个操作在 Redis 中实现成一个操作；

- **Lua 脚本**：把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。

单命令操作就是一个命令中带有多个数据操作，比如：读取数据、数据增减、写回数据三个操作。如 INCR/DECR 命令可以对数据进行增值 / 减值操作。

单命令的问题：当我们需要对读取的数据做更多判断，或者是我们对数据的修改不是简单的增减时，单命令操作就不适用了。

Lua 脚本的优势：Redis 的 Lua 脚本可以包含多个操作，这些操作都会以原子性的方式执行，绕开了单命令操作的限制。

Lua 脚本的问题：如果把很多操作都放在 Lua 脚本中原子执行，会导致 Redis 执行脚本的时间增加，同样也会降低 Redis 的并发性能。所以，在编写 Lua 脚本时，避免把不需要做并发控制的操作写入脚本中。

## 12、Redis 内存容量增加后，会带来什么问题？

悟空拧螺丝 2021-07-24

> Redis 内存容量增加后，会带来什么问题？

Redis 使用内存保存数据，内存容量增加后，就会带来两方面的潜在问题，分别是：

- 内存快照 RDB 生成和恢复效率低。
- 主从节点全量同步时长增加、缓冲区易溢出。

### 内存快照 RDB 受到的影响

内存大小和内存快照 RDB 的关系是非常直接的：实例内存容量大，RDB 文件也会相应增大，那么，RDB 文件生成时的 fork 时长就会增加，这就会导致 Redis 实例阻塞。而且，RDB 文件增大后，使用 RDB 进行恢复的时长也会增加，会导致 Redis 较长时间无法对外提供服务。

### 主从同步受到的影响

主从节点间的同步的第一步就是要做全量同步。全量同步是主节点生成 RDB 文件，并传给从节点，从节点再进行加载。试想一下，如果 RDB 文件很大，肯定会导致全量同步的时长增加，效率不高，而且还可能会导致复制缓冲区溢出。一旦缓冲区溢出了，主从节点间就会又开始全量同步，影响业务应用的正常使用。如果我们增加复制缓冲区的容量，这又会消耗宝贵的内存资源。

## 13、为了保证缓存和数据库一致性，说说只读缓存的方案？

悟空拧螺丝 2021-07-24

> 为了保证缓存和数据库一致性，说说只读缓存的方案？

- **有数据新增时**，会直接写入数据库；

- **有数据删改时**，就需要把只读缓存中的数据**标记为无效**。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。

**建议**：优先使用先更新数据库再删除缓存的方法。

**原因**：先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。

总结见下图：

![](http://cdn.jayh.club/blog/20210725/0X8u5YhdBk5c.png?imageslim)

## 14、Redis 有慢查询怎么办？

* [x] 公众号

悟空拧螺丝 2021-07-26

> Redis 有慢查询怎么办？

### 慢查询日志

#### 获取慢查询日志

```sh
showlog get [N]
```

日志包含四个部分：日志的标识 id、发生时间戳、命令耗时、执行命令和参数。

#### 获取慢查询日志列表的当前的长度

``` sh
showlog len
```

#### 清空慢查询日志

``` sh
showlog reset
```

### 慢查询命令的复杂度

命令的慢操作和操作的复杂度相关。操作度复杂度查询：

```HTML
https://redis.io/commands
```

当发现 Redis 性能变慢时，可以通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。

比如我们可以看到 `keys`命令的复杂度为 O(N)。如下图所示：

![](http://cdn.jayh.club/blog/20210726/BUbSMxmoW7SM.png?imageslim)

### 用高效命令替换

如果的确有大量的慢查询命令，用其他高效命令代替。

- 当需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。

- 需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。

KEYS 命令需要遍历存储的键值对，所以操作延时高。KEYS 命令一般不被建议用于生产环境中。

### 最佳实践

关于慢查询日志的配置有两个：slowlog-max-len、slowlog-log-slower-than

#### slowlog-max-len

**作用**：慢查询日志最多存储多少条。

**默认值**：

从源码中我们可以找到这个选项的默认值为 128

![](http://cdn.jayh.club/blog/20210726/OTgT9iQkOrDv.png?imageslim)

**配置建议**：线上建议调大慢查询列表，避免长命令在记录时被截断，且不会占用大量内存。线上可以配置为 1000 以上。

#### slowlog-log-slower-than

**作用**：慢查询的预设阀值，当命令的耗时超过这个配置就会被记录到慢查询日志中。

**默认值**是 10 ms。

![](http://cdn.jayh.club/blog/20210726/NzgbEhqI2bFm.png?imageslim)

**配置建议**：默认值超过 10ms 被判定为慢查询，需要根据并发量来调整，高流量场景 配置为 1 ms。

将慢查询日志持久化到数据库，避免丢失日志，而且可以开发可视化的查询界面供运维排查。



巨人的肩膀：

Redis 6.0 源码

https://time.geekbang.org/column/article/286549

《Redis 开发与运维》

## 15、Redis 过期策略是怎么样的？

定期删除+惰性删除。

#### 惰性删除

概念：在获取某个 key 的时候，Redis 会检查下这个 key 是否过期了，如果过期了则删除，且不会返回任何东西。

优点：不会删除其他键，所以不会花费任何 CPU 时间在其他无关的过期键上。

缺点：大量过期键未被访问，无法自动释放，造成数据积压，可以看作是内存泄漏。

源码解析：

- db.c/expireIfNeeded 删除过期键，Redis 命令在执行之前都会调用这个函数对输入键进行检查。原理如下图所示：

![](http://cdn.jayh.club/blog/20210729/E4nVOqddt2Mm.png?imageslim)

- GET 命令，判断当键存在时，按照键存在的情况执行。当键不存在时，返回空。原理如下图所示：

![](http://cdn.jayh.club/blog/20210729/RqysdiHubnNr.png?imageslim)

#### 定期删除

概念：每隔默认的 100 ms 随机抽取一些设置了过期时间的 key，检查是否过期，如果过期就删除。

优点：

- 限制操作执行的时常和频率来减少删除操作对 CPU 时间的影响。
- 减少了因为过期键而带来的内存消费。

缺点：

- 如果定时删除执行得太频繁，或者执行的时间太长，CPU 时间就会过多地消耗在删除过期键上面
- 如果删除操作执行得太少，或者执行的时间太短，则会出现和惰性删除一样的问题，内存浪费或数据积压。

源码解析：

- 每当 Redis 服务器的周期性操作 redis.c/serverCron 函数执行时，redis.c/activeExpireCycle 会被调用。

- activeExpireCycle 函数在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的 expires 字典中随机检查一部分键的过期时间，并删除其中的过期键。
- current_db 记录当前检查的数据库，如果函数 activeExpireCycle 当前正在处理 2 号数据库，时间超限，返回后，下次检查时，会从 3 号数据库开始检查。所有数据库检查一遍后，current_db 重置为 0，然后再次开始一轮的检查工作。







## 16.Redis 性能问题排查

Redis 性能变慢时，按照这些步骤逐一检查，高效地解决问题。

- 获取 Redis 实例在当前环境下的基线性能。命令：./redis-cli --intrinsic-latency 120。用来监测和统计测试期间内的最大延迟
- 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。
- 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。
- 是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。
- Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。
- Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。
- 在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。
- 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。
- 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。





## 待优化

悟空拧螺丝 2021-07-27

> 说说 Redis 分布式锁和 Zookeeper 分布式锁的区别

### 原理

#### Redis 分布式锁原理

Redis 分布式锁，可以参考这篇：《》

Redis 的常用的分布式锁方案：使用 Lua 脚本进行获取锁、比较锁、删除锁的原子操作。

原理如下：

![](http://cdn.jayh.club/blog/20210727/Ij4GT545zrJn.png?imageslim)

我们先来看一下这段 Redis 专属脚本：

```sh
if redis.call("get",KEYS[1]) == ARGV[1]
then
    return redis.call("del",KEYS[1])
else
    return 0
endCopy to clipboardErrorCopied
```

先获取 KEYS[1] 的 value，判断 KEYS[1] 的 value 是否和 ARGV[1] 的值相等，如果相等，则删除 KEYS[1]。

那么这段脚本怎么在 Java 项目中执行呢？

分两步：先定义脚本；用 redisTemplate.execute 方法执行脚本。

```java
// 脚本解锁
String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList("lock"), uuid);Copy to clipboardErrorCopied
```

上面的代码中，KEYS[1] 对应`“lock”`，ARGV[1] 对应 `“uuid”`，含义就是如果 lock 的 value 等于 uuid 则删除 lock。

而这段 Redis 脚本是由 Redis 内嵌的 Lua 环境执行的，所以又称作 Lua 脚本。

### 性能方面

Redis 分布式锁，需要自己不断去尝试获取锁，比较消耗性能。

Zookeeper 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较

小。

### 风险

Redis 获取锁的那个客户端宕机了，那么只能等待超时时间之后才能释放锁；而 Zookeeper  的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。

### 易用度

Redis 分布式锁需要遍历上锁，计算时间等等，较为麻烦。zk 的分布式锁语义清晰实现简单。

### 锁释放

Zookeeper 创建的是临时顺序节点，所以在出现下面两种情况时，都会自动释放锁：

- 任务完成后，Client会自动释放锁。

- 任务没完成，Client崩溃了，自动释放锁。

Redis 是通过 Lua 脚本中的 del 命令解锁。







每天一道面试题-悟空聊架构  15/365

悟空拧螺丝 2021-07-27

> 简单说下缓存和数据库的数据不一致

**不一致的情况**：

- 缓存中有数据，那么，缓存的数据值需要和数据库中的值不相同。

- 缓存中本身没有数据，数据库中的值不是最新值。

**操作缓存的模式**：

根据是否接收写请求，分为读写缓存和只读缓存。



* [x] 已同步至面试突击公众号？

* [x] 已同步至知识星球？

> 有哪些与 Redis 交互的操作？

面试者小空听到这题后，窃喜，这题简单，不假思索地回答：键值对  的读和写。

面试官面无表情的说道：还有吗？

小空支支吾吾的没有答上来。

面试官继续说：和 Redis 实例交互的对象分别有四种：**客户端、磁盘、主从节点、切片集群实例**。

**这些对象和 Redis 交互时，有不同的操作：**

`客户端对象`会有网络 IO交互、键值对 增删改查 操作、数据库操作。

`磁盘对象`会有生成 RDB 快照、记录 AOF 日志、AOF 日志重写操作。

`主从节点`对象会有主库生成、传输 RDB 文件、从库接受 RDB 文件、清空数据库、加载 RDB 文件操作。。

`切片集群实例`对象会有向其他实例传输哈希槽信息、数据迁移操作。

小空听完后，叹了一口气，今天又是被面试官吊打的一天。

