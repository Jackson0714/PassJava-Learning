本文由梅一凡和悟空共同整理。

### 什么是 Spring

Spring 是一个轻量级的 java 开发框架，解决企业应用开发的业务逻辑层和各层的耦合问题

### 为什么要使用 Spring

- 属于低侵入式设计，代码的污染极低
- Aop 面向切面编程
- IOC 控制反转
- 对于主流的应用框架提供了集成的支持

### 你们项目中为什么使用 Spring 框架？

这么问的话，就直接说 Spring 框架的好处就可以了。比如说 Spring 有以下特点：

**轻量：**Spring 是轻量的，基本的版本大约 2MB。

**控制反转：**Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找

依赖的对象们。

**面向切面的编程** (AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。

**容器：**Spring 包含并管理应用中对象的生命周期和配置。

**MVC **框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。

**事务管理：**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务

（JTA）。

**异常处理：**Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛

出的）转化为一致的 unchecked 异常。

### AOP

aop 是面向切面编程，用于将一些与业务无关的，但却对多个对象产生影响的公共行为和逻辑，抽取出来封装成一个模块，而这个模块就叫做**切面**。优点：减少系统中的重复代码，降低了模块间的耦合度，提高了系统的可维护性。主要用**权限认证、日志、事务处理**

aop 的实现关键主要在于代理模式，分为** JDK 动态代理和 CGLIB 动态代理**

#### JDK 动态代理和 CGLIB 动态代理对比

- **JDK 动态代理只提供接口的代理，不支持类的代理。**核心 InvocationHandler 接口和 Proxy 类，InvocationHandler 通过的是 invoke（）方法反射来代用目标类中的代码的。动态将逻辑和业务绑定在一起 。Proxy 是利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象
- 如果代理类中没实现 InvocationHandler 接口，那么 Aop 会选择使用 CGLIB 来动态代理目标类。CGLIB 是一个代码生成的类库，可以在运行时动态生成指定类的一个子类对象，并且覆盖其中特定的方法来实现的 aop。CGLIB 是通过继承的方式做的动态代理。所以如果某各类被 标记为 final，那么他是无法使用 CGLIB 代理的

#### aop 中切面、切点、连接点、通知之间的关系

1、切面：就是将公共行为封装成模块之后的类

2、切点：描述何时执行通知的规则

3、连接点：被切点匹配执行通知的位置

4、通知：是程序公共行为执行的代码操作

### IOC

   - IOC 是控制反转，指的是创建对象的控制权利的转移，以前创建对象的主动权是自己，而现在 是将主动权交给了 Spring 去管理，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，有利用功能的复用。DI 依赖注入，和 IOC 是同一个概念的不同角度的描述，一个程序在运行时依赖 IOC 容器来动态注入对象 需要的外部资源
   - IOC 就是 创建对象的时候不用在去 new 了，可以通过 Spring 自动生产，使用 java 的反射机制，根据配置文件运行时动态去创建和管理，之后再去调用
   - Spring 的 IOC 是由三种注入方式：构造器注入、set 方法注入、根据注解注入

### Spring Bean 的作用域范围

作用域范围：

- Singleton（单例） 在整个应用中，只创建 bean 的一个实例

- Propotype（原型） 每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的 bean 实例。

- Session（会话） 在 Web 应用中，为每个会话创建一个 bean 实例。

- Request（请求） 在 Web 应用中，为每个请求创建一个 bean 实例。

他们是什么时候创建的：

- 一个单例的 bean, 而且 lazy-init 属性为 false（默认）, 在 Application Context 创建的时候构造

- 一个单例的 bean,lazy-init 属性设置为 true, 那么，它在第一次需要的时候被构造。
- 其他 scope 的 bean, 都是在第一次需要使用的时候创建

他们是什么时候销毁的：

- 单例的 bean 始终 存在与 application context 中，只有当 application 终结的时候，才会销毁

- 和其他 scope 相比，Spring 并没有管理 prototype 实例完整的生命周期，在实例化，配置，组装对象交给应用后，Spring 不再管理。只要 bean 本身不持有对另一个资源（如数据库连接或会话对象）的引用，只要删除了对该对象的所有引用或对象超出范围，就会立即收集垃圾。
- Request: 每次客户端请求都会创建一个新的 bean 实例，一旦这个请求结束，实例就会离开 scope, 被垃圾回收。
- Session: 如果用户结束了他的会话，那么这个 bean 实例会被 GC.

### SpringMVC 的原理

![img](https://camo.githubusercontent.com/14ffd5b775de83e2627ebbb197bf89f6546360f9/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3234393939332f3230313631322f3234393939332d32303136313231323134323534323034322d323131373637393139352e6a7067)

客户端发起请求到 dispatchservlet，dispatchservlet 根据请求调用 handlerMappering，解析出一个对应的 handler，解析出的 handler 由 handlerAdapter 适配器去处理完成之后得到对应的 moudleAndView, 最后将 view 返回给客户

### AOP 的应用场景有哪些呢

1、日志记录

2、权限验证

3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis 分布式锁等功能）

4、事务管理（Spring 的事务就是用 AOP 实现的）

### Spring 中循环依赖的解决方案

![](http://cdn.jayh.club/uPic/image-20220704205753879e2JLgq.png)

1. 使用 context.getBean(A.class)，获取容器内的单例 A（若 A 不存在，就会走 A 这个 Bean 的创建流程），显然初次获取 A 是不存在的，因此走 A 的创建之路~

2. 实例化 A（注意此处仅仅是实例化），并将它放进缓存（此时 A 已经实例化完成，已经可以被引用了）

3. 初始化 A：@Autowired 依赖注入 B（此时需要去容器内获取 B）

4. 为了完成依赖注入 B，会通过 getBean(B) 去容器内找 B。但此时 B 在容器内不存在，就走向 B 的创建之路~

5. 实例化 B，并将其放入缓存。（此时 B 也能够被引用了）

6. 初始化 B，@Autowired 依赖注入 A（此时需要去容器内获取 A）

7. 此处重要：初始化 B 时会调用 getBean(A) 去容器内找到 A，上面我们已经说过了此时候因为 A 已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在 A 的引用了的，所以 getBean(A) 能够正常返回

8. B 初始化成功（此时已经注入 A 成功了，已成功持有 A 的引用了），return（注意此处 return 相当于是返回最上面的 getBean(B) 这句代码，回到了初始化 A 的流程中~）。

9. 因为 B 实例已经成功返回了，因此最终 A 也初始化成功

10. 到此，B 持有的已经是初始化完成的 A，A 持有的也是初始化完成的 B

    我们开始三级缓存，首先通过 A 进入已经缓存，去寻找发现没有初始化的 B(**并且他使用了 singlobject 提前曝光了自己**) 在去二级缓找发现没有 B, 就去开启了创建 B,

    B 开始从一级缓存寻找 A 发现没有 A, 但是鱿鱼我们的 A 刚刚提前曝光了自己，我们 B 可以获取到 A(**但是这个 A 并不是初始化的而是实例化的但是 A 可以被引用）**我们 B 待着 A 去三级缓存最实例化了，现在我们的 B 是实例化的，我回到刚刚的 A 在去获取 b 发现可以获得一个实例化好的 B, 然后在去三级缓存最后把自己也成功了实例化了这个时候我们的 A 和 B 都已经实例化过来就不会出现循环依赖的问题了

### Spring 框架中的单例 Beans 是线程安全的么

谈到 beans 线程安全那么就看 bean 是否有多种状态，如果始终只有一种状态 就是线程安全的，否则需要自己去保证线程的安全，可以采用将 singleton 变为 prototype

### @autowired 和@resource 注解的区别是什么

autowired 是按照 bytype 注入的，是由 Spring 提供的，resource 是 j2ee 提供的，按照名字去注入的

如果一个接口有多个实现，那么采用 Qualifier

### 什么时候 Spring 事务不生效

- innodb 支持事务，mysiam 不支持事务
- 私有和受保护的事务不生效
- 如果定义了事务注解被别的任务调用此时事务不生效
- 默认的异常是运行时异常，所以要想事务注解生效必须加上 rollbackfor。