# 单例模式 Singleton Design Pattern

一个类只允许创建一个对象（或者叫实例）

## 单例的场景

有些数据只应该保存一份，比如系统的配置信息。

单例解决资源访问冲突。

## 单例关注点

- 构造函数是 private 的，避免外部通过 new 创建实例。
- 考虑对象创建时的线程安全问题。
- 考虑是否支持延迟加载。
- 考虑是否支持延迟加载。
- 考虑 getInstance() 性能是否高。

## 单例的几种方式

### 饿汉式

类加载期间，已经将 instance 静态实例初始化好了，不支持延迟加载。

### 懒汉式

支持延迟加载，会导致频繁加锁、释放锁，以及并发度低邓文，频繁的调用会产生性能瓶颈。

### 双重检测

支持延迟加载，支持高并发。

### 静态内部类

利用 Java 的静态内部类来实现单例。既支持延迟加载，也支持高并发，实现起来比双重检测简单。

## 单例的问题

- 单例对 OOP 特性的支持不友好。
- 单例会隐藏类之间的依赖关系。
- 单例对代码的扩展性不友好。
- 单例对代码的可测试性不友好。
- 单例不支持有参的构造函数

替代解决方案：

- 为了保证全局唯一，可以使用静态方法来实现。但不能解决之前提到的问题。
- 通过工厂模式，IOC 容器来保证。
- 由程序员自己来保证，不要创建两个类对象。

模式没有对错，关键看怎么用。

适合用单例模式的场景：

- 如果单例类没有后续的扩展需求，并且不依赖外部系统，设计成单例类就没有太大问题。
- 对于一些全局的类，在其他类之间还需要传来传去，则做成单例类，使用起来方便。

## 集群环境的单例模式

### 单例模式的唯一性

进程内唯一，进程间不唯一。

### 线程唯一的单例

用 Java 提供的 ThreadLocal 并发工具类来实现。

### 集群唯一的单例

把单例对象序列化并存储到外部共享存储区（比如文件）。进程使用时，要先从外部共享存储区读取到内存中，并反序列化成对象，然后再使用，使用完后序列化并存储到共享存储区。使用对象时，需要对其进行加锁。

### 多例模式

一个类可以创建多个对象。
