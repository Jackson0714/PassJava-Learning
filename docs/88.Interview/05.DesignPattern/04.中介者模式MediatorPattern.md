# 中介者模式

GoF 设计模式中的定义：

> Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly  

翻译成中文：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。  

想一下微服务中的注册中心，这不正是中介者么，所有微服务想要调用其他微服务，都需要从注册中心拿到其他微服务的地址。

坏处：

- 中介者要干的活太多了，容易造成这个类的代码量很大。
- 如果这个中介者是一个服务，那么很多服务都依赖这个服务，容易造成高可用瓶颈，当然还可以通过扩容中介者来提升可用性，但是维护成本也随之增加。
- 中介者更像是一个掌控全局的类，承担了很多其他类的职责，大而复杂。

所以需要平衡对象之间交互的复杂度和中介类本身的复杂类。

### 中介者 VS 观察者模式的对比

#### 观察者

经典的观察者模式没有彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 update() 方法。

跨进程的实现方式中，可以用消息队列彻底解耦。

#### 中介者

中介者也是为了实现解耦，而消息队列就可以当做一个中介者。

观察者模式中，一个参与者一般只有一种身份，要么是观察者，要么是被观察者。大部分情况西，参与者之间的交互比较简单，都是单向的。

中介者模式中，参与者之间交互成本很高，用中介模式，另外需要保证调用顺序的时候，可以通过中介者来保证顺序。当用消息队列作为中介者时，参与者既可以是消息的发送者，也可以是消息的接收者。

