## Redis 分布式锁｜从青铜到钻石的演进方案

上篇我们讲到如何用本地内存和 Redis《插入文涨》 做缓存来增强系统的性能，另外探讨了加锁解决缓存击穿的问题。但是`本地加锁`的方式在分布式的场景下就不适用了，所以本文我们来探讨下如何引入`分布式锁`解决本地锁的问题。

本篇主要内容如下：

《思维导图》

## 一、本地锁的问题

首先我们来回顾下本地锁的问题：

目前题目微服务被拆分成了四个微服务。前端请求进来时，会被转发到不同的微服务。假如前端接收了 10 W 个请求，每个微服务接收 2.5 W 个请求，假如缓存失效了，每个微服务在访问数据库时加锁，通过锁（synchronzied 或 lock）来锁住自己的线程资源，从而防止缓存击穿。

这是一种本地加锁的方式，在分布式情况下会带来数据不一致的问题：比如服务 A 获取数据后，更新缓存 key =100，服务 B 不受服务 A 的锁限制，并发去更新缓存 key = 99，最后的结果可能是 99 或 100，但这是一种未知的状态，与期望结果不一致。流程图如下所示：

![](http://cdn.jayh.club/uPic/image-20210424123518280.png)

## 二、什么是分布式锁

基于上面本地锁的问题，我们需要一种支持分布式集群环境下的锁：查询 DB 时，只有一个线程能访问，其他线程都需要等待第一个线程释放锁资源后，才能继续执行。

我们来看下分布式锁的基本原理，如下图所示：

![](http://cdn.jayh.club/uPic/image-20210426173605882.png)

我们来分析下上图的分布式锁：

- 1.前端将 10W 的高并发请求转发给四个题目微服务。
- 2.每个微服务处理 2.5 W 个请求。
- 3.每个处理请求的线程在执行业务之前，需要先抢占锁。可以理解为“占坑”。
- 4.获取到锁的线程在执行完业务后，释放锁。可以理解为“释放坑位”。
- 5.未获取到的线程需要等待锁释放。
- 6.释放锁后，其他线程抢占锁。
- 7.重复执行步骤 4、5、6。

大白话解释：所有请求的线程都去同一个地方`“占坑”`，如果有坑位，就执行业务逻辑，没有坑位，就需要其他线程释放“坑位”。这个坑位是所有线程可见的，可以把这个坑位放到 Redis 缓存或者数据库，这篇讲的就是如何用 Redis 做`“分布式坑位”`。

## 三、Redis 的 SETNX

Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。

用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。

我们来看下这个命令，`SETNX`是`set If not exist`的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做。

在 Redis 命令行中是这样执行的：

```sh
set <key> <value> NX
```

我们可以进到 redis 容器中来试下 `SETNX` 命令。

先进入容器：

```sh
docker exec -it <容器 id> redid-cli
```

然后执行 SETNX 命令：将 `wukong` 这个 key 对应的 value 设置成 `1111`。

``` sh
set wukong 1111 NX
```

返回 `OK`，表示设置成功。重复执行该命令，返回 `nil`表示设置失败。

![](http://cdn.jayh.club/uPic/image-20210427161948549.png)

## 四、青铜方案

我们先用 Redis 的 SETNX 命令来实现最简单的分布式锁。

### 3.1 青铜原理

我们来看下流程图：

![](http://cdn.jayh.club/uPic/image-20210427165603245.png)

- 多个并发线程都去 Redis 中申请锁，也就是执行 setnx 命令，假设线程 A 执行成功，说明当前线程 A 获得了。
- 其他线程执行 setnx 命令都会是失败的，所以需要等待线程 A 释放锁。
- 线程 A 执行完自己的业务后，删除锁。
- 其他线程继续抢占锁，也就是执行 setnx 命令。因为线程 A 已经删除了锁，所以又有其他线程可以抢占到锁了。

代码示例如下，Java 中 setnx 命令对应的代码为 `setIfAbsent`。

```java
// 1.先抢占锁
Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock", "123");
if(lock) {
  // 2.抢占成功，执行业务
  List<TypeEntity> typeEntityListFromDb = getDataFromDB();
  // 3.解锁
  redisTemplate.delete("lock");
  return typeEntityListFromDb;
} else {
  // 4.休眠一段时间
  sleep(100);
  // 5.抢占失败，等待锁释放
  return getTypeEntityListByRedisDistributedLock();
}
```

那为什么需要休眠一段时间？







## 四、白银方案





## 五、黄金方案



## 六、铂金方案



## 七、钻石方案

