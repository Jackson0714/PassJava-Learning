# 呀，注册中心居然藏了一个优秀的缓存架构！

上一讲我们讲到了 Eureka Server 有两级缓存来保存注册信息，来回顾下：

Server 端那边有缓存机制，分为两级缓存，只读缓存 readOnlyCacheMap 和读写缓存 readOnlyCacheMap。

- 默认会先从只读缓存里面找。
- 没有的话，再从读写缓存里面找。
- 找到了的话就更新只读缓存，并返回找到的缓存。
- 还找不到的话，就返回空。

![](http://cdn.jayh.club/blog/20211013/2t7Byj8TBd8H.png)

带来了三个问题：

（1）两级缓存数据怎么来的？

（2）缓存数据如何更新的？

（3）缓存如何过期？



## 过期

### 主动过期

读写缓存

服务实例注册、下线、故障的时候，会刷新 readWriteCacheMap。

Eureka Server 自己注册的时候，会刷新吗？



\eureka\eureka-core\src\main\java\com\netflix\eureka\resources\ApplicationResource.java

```
registry.register(info, "true".equals(isReplication));
```

AbstractInstanceRegistry.java, register 方法

invalidate 方法

### 定时过期

读写缓存

每隔 180s 会自动过期**读写缓存。如何加回来呢？**

\eureka\eureka-core\src\main\java\com\netflix\eureka\registry\ResponseCacheImpl.java

ResponseCacheImpl 构造函数里面 构造了一个 readWriteCacheMap，180s 后，主动过期

```
expireAfterWrite(180s)
```

### 被动过期

只读缓存

每隔 30s 将读写缓存同步到**只读缓存**。

```java
getCacheUpdateTask()
```
