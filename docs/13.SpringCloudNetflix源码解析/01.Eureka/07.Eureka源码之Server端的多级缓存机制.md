# 呀，Eureka 居然藏了一个优秀的缓存架构！

## 一、前言

上一讲我们讲到了 Eureka Server 有两级缓存来保存注册信息，来回顾下：

Server 端那边有缓存机制，分为两级缓存，只读缓存 readOnlyCacheMap 和读写缓存 readOnlyCacheMap。

看图更清晰，如下图所示：

![](http://cdn.jayh.club/blog/20211102/BuD0hsas1RKB.png)

本篇悟空会带着大家来看下 Eureka 的缓存架构是怎么样，通过学习这篇，我们也可以借鉴 Eureka 的缓存设计思想，将其运用到项目当中。

## 二、引发的几个思考

我们再来看下 Eureka 源码，其实不难看懂，下面会做解释。

![](http://cdn.jayh.club/blog/20211013/2t7Byj8TBd8H.png)

- 默认会先从`只读`缓存里面找。
- 没有的话，再从`读写`缓存里面找。
- 找到了的话就更新只读缓存，并返回找到的缓存。
- 还找不到的话，就返回空。

带来了三个问题：

（1）两级缓存数据怎么来的？

（2）缓存数据如何更新的？

（3）缓存如何过期？

首先我们先来看下其中的一种缓存结构：读写缓存。

## 三、读写缓存

读写缓存，顾名思义，就是既可以进行读，也可以进行写的缓存。

那用在哪里呢？

### 2.1 写操作时机的原理

当有新的服务实例进行注册或者下线、发生故障时，就会把这个缓存给刷新一下，也就是进行写操作。

如下图所示，最上面的时注册中心，下面三个是服务实例。服务实例发生注册、下线、发生故障，注册中心都是可以感知到的，然后就会主动刷新只读缓存。

![](http://cdn.jayh.club/blog/20211102/FCxGlrfKEdA6.png)

### 2.2 写操作源码

从源码层面我们再来看下读写缓存是什么时候进行写操作的。





## 二、只读缓存数据怎么来的？



## 三、缓存数据如何更新的？

## 四、缓存数据如何过期的？



## 过期

### 主动过期

读写缓存

服务实例注册、下线、故障的时候，会刷新 readWriteCacheMap。

Eureka Server 自己注册的时候，会刷新吗？



\eureka\eureka-core\src\main\java\com\netflix\eureka\resources\ApplicationResource.java

```
registry.register(info, "true".equals(isReplication));
```

AbstractInstanceRegistry.java, register 方法

invalidate 方法

### 定时过期

读写缓存

每隔 180s 会自动过期**读写缓存。如何加回来呢？**

\eureka\eureka-core\src\main\java\com\netflix\eureka\registry\ResponseCacheImpl.java

ResponseCacheImpl 构造函数里面 构造了一个 readWriteCacheMap，180s 后，主动过期

```
expireAfterWrite(180s)
```

### 被动过期

只读缓存

每隔 30s 将读写缓存同步到**只读缓存**。

```java
getCacheUpdateTask()
```
